"""
.. module:: Symbol
   :platform: Unix, Windows
   :synopsis: Classes for representing and generating symbols in HRRs.

.. moduleauthor:: Andrew Mundy <mundy@cs.manchester.ac.uk>

"""
from utils import *

def parent_match( f ):
    # Create a new function which first ensures that args' parents match
    def f_( self, other ):
        if not self.parent == other.parent:
            raise ValueError( "Only Symbols drawn from the same " \
                          "SymbolFactory may be used in this operation." )

        return f( self, other )

    # Copy over the documentation
    f_.__doc__ = f.__doc__
    return f_

class SymbolFactory( object ):
    """
    A SymbolFactory provides a common source of symbols and vectors.

    Typical usage is::

        factory = SymbolFactory( 512, vec_generate, Symbol )

    Which returns a factory with dimensionality 512, randomly generated
    vectors using the default generator, and generates Symbol instances.
    
    :param dimensionality: The dimensionality of any vectors/symbols
        generated by this factory.
    :type dimensionality: int
    :param vec_generator: The function used to generate any vectors
        used to represent symbols generated by this factory.
        This function must accept a dimensionality and return a valid
        vector of that size.
    :type vec_generator: function
    :param symbol_type: The function used to turn a vector and a
        label into a valid Symbol.  This function must accept a label
        and a vector and return an instance of a Symbol, or Symbol
        derived class.
    :type symbol_type: class or function

    """
    def __init__( self, dimensionality, vec_generator, symbol_type ):
        # Store the constants
        self.dimensionality = lambda : dimensionality
        self.generate_vector = lambda : vec_generator( self.dimensionality() )
        self._symbol_type = symbol_type
    
    def make_symbol( self, label, vector ):
        """Make a new symbol with the given label and vector.
    
        :param label: The label to be associated with the new symbol.
        :type label: str
        :param vector: The vector to be used for the new symbol.
    
        :returns: A Symbol of the type generated by the factory with the given
            label, and the appropriate vector.  This is a useful function to
        use if you need a conformant symbol with the correct vector
        properties.

        :throws ValueError: The vector provided has the wrong dimensionality.
        """
        vector = array( vector )
        
        if not vector.size == self.dimensionality():
            raise ValueError( "Can only make Symbols with dimensionality " \
                              "%d" % self.dimensionality() )

        s = self._symbol_type( self, label, vector )
        assert isinstance( s, Symbol )
        return s
    
    def new_symbol( self, label ):
        """Generate a new symbol with the given label.
    
        :param label: The label to be associated with the new Symbol.
        :type label: string
    
        :returns: A Symbol-derived class using with a vector generated by the 
            factory's generation function, formed into a Symbol with the
            given label by the factory's symbol creation function.
        """
        # Create a vector
        v = self.generate_vector()

        # Create and return the symbol
        return self.make_symbol( label, v )
    
    def compositional_identity( self ):
        """:returns: The null symbol for composition."""
        # Create the vector
        v = zeros( self.dimensionality() )

        # Create and return the symbol
        return self.make_symbol( "~0", v )
    
    def binding_identity( self ):
        """:returns: The null symbol for binding."""
        # Create the vector
        v = hstack( [[1], zeros( self.dimensionality() - 1 )] )

        # Create and return the symbol
        return self.make_symbol( "~1", v )

class Symbol( object ):
    """Provides the interface expected of all Symbols.  Typically
    a derived Symbol type will be used (e.g. 
    :class:`.SaturatingSymbol`).

    A symbol object represents a symbol within an HRR system.  For ease
    of use a label is stored with the symbol, and the entire construct is
    immutable once generated.
    
    **You will normally never need to instantiate with this class as is.**
    Symbols should almost always be generated using a
    :class:`.SymbolFactory`

    :param parent: The :class:`.SymbolFactory` from which
        this Symbol was derived.
    :type parent: :class:`.SymbolFactory`
    :param label: The label for this Symbol, e.g., "dog".
    :type label: string
    :param vector: Vector to represent this Symbol.
    """

    def __init__( self, parent, label, vector ):
        # Store the constants as the return values of functions
        self.parent = parent
        self.label = lambda : label
        self.vector = lambda : array( vector )
        self.dimensionality = lambda : self.vector().size
    
    def __str__( self ):
        return self.label()
    
    def inverse( self ):
        """
        :returns: The approximate inverse of the symbol for use in
            unbinding operations.

        """
        # Create the inverse vector
        v = hstack( [ self.vector()[0], self.vector()[-1:0:-1] ] )

        # Create a new Symbol of this type with label' and the vector
        return self.parent.make_symbol( "%s'" % self, v )
    
    @parent_match
    def bind( self, other ):
        """Bind two Symbols of equivalent type and dimensionality.
    
        :param other: Symbol with which to bind this Symbol.
        :type other: :class:`.Symbol`
    
        :returns: A Symbol representing the binding of this Symbol with another.
            The label of the returned Symbol will indicate this relationship.
        """
        # Combine the labels
        l_ = "( %s (*) %s )" % (self, other)

        # Combine the vectors
        v_ = vec_convolve_circular( self.vector(), other.vector() )

        # Create and return a new Symbol
        return self.parent.make_symbol( l_, v_ )
    
    @parent_match
    def unbind( self, other ):
        """Unbind two Symbols of equivalent type and dimensionality.
            
        :param other: Symbol to unbind from this Symbol.
        :type other: :class:`.Symbol`
        
        :returns: The (noisy) result of unbinding the given Symbol with this
            Symbol.
        :rtype: :class:`.Symbol`
        """
        return self.bind( other.inverse() )
    
    @parent_match
    def compose( self, other ):
        """Compose this Symbol with another.
    
        :param other: Symbol to add to this Symbol.
        :type other: :class:`.Symbol`
    
        :returns: The additive composition of this Symbol and another.
        :rtype: :class:`.Symbol`
        """
        # Combine the labels
        l_ = "( %s + %s )" % ( self, other )

        # Combine the vectors
        v_ = self.vector() + other.vector()

        # Create and return a new Symbol
        return self.parent.make_symbol( l_, v_ )
    
    def scale( self, scale ):
        """Return the current Symbol scaled by some factor.
        
        :param scale: The scaling factor.
        :type scale: Number
        
        :returns: Symbol scaled by the given factor.
        :rtype: :class:`.Symbol`
        """
        if not isinstance( scale, numbers.Number ):
            raise ValueError( "You may only scale a Symbol by a Number." )

        # Create the new label
        l_ = "( %.3f %s )" % ( scale, self )

        # Generate the new vector
        v_ = scale * self.vector()

        # Create and return a new Symbol
        return self.parent.make_symbol( l_, v_ )
    
    def exponentiate( self, n ):
        """Return the current Symbol raised to the power of `n1`.
        
        :param n: Power to raise the Symbol to.
        :type n: Number
    
        :returns: Symbol raised to power `n`.
        :rtype: :class:`.Symbol`
        """
        if not isinstance( n, numbers.Number ):
            raise ValueError("You may only scale a exponentiate by a Number.")

        # Create the new label
        l_ = "( %s^{%.3f} )" % ( self, n )

        # Generate the new vector
        v_ = vec_exponentiate( self.vector(), n )

        # Create and return a new Symbol
        return self.parent.make_symbol( l_, v_ )
    
    @parent_match
    def compare( self, other ):
        """Compare this Symbol with another.
    
        :param other: Symbol with which to compare this Symbol.
        :type other: :class:`.Symbol`
    
        :returns: The cosine of the angle between this Symbol and the other.
        :rtype: float
        """
        return vec_cosine( self.vector(), other.vector() )
    
    def magnitude( self ):
        """Return the magnitude of the vector representing this Symbol.
        :rtype: float
        """
        return vec_magnitude( self.vector() )

class SaturatingSymbol( Symbol ):
    """A Symbol which models saturation of the value of components.
    On instantiation a saturating function is used modify the vector
    used to represent the Symbol.  This saturation function represents the
    effect of using population of neurons to represent a vector.

    :param parent: The :class:`.SymbolFactory` from which
        this Symbol was derived.
    :type parent: :class:`.SymbolFactory`
    :param label: The label for this Symbol, e.g., "dog".
    :type label: string
    :param vector: Vector to represent this Symbol.
    :param saturation: Function which is applied to saturate the
        representing vector, must accept and return a vector.
        The default is :meth:`utils.saturation_sigmoid`
    :type saturation: function

    """

    def __init__(self, parent, label, vector, saturation=saturation_sigmoid):
        # Saturate the input vector
        vector = saturation( vector )

        # Now act as normal by calling super init
        super( SaturatingSymbol, self ).__init__( parent, label, vector )
